%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <pygtk/pygtk.h>

#include "gedit-language-manager.h"
#include "gedit-plugin.h"
#include "gedit-app.h"
#include "gedit-encodings.h"
#include "gedit-enum-types.h"
#include "gedit-statusbar.h"
#include "gedit-debug.h"
#include "gedit-message-bus.h"
#include "gedit-message.h"

void pygedit_register_classes (PyObject *d); 
void pygedit_add_constants (PyObject *module, const gchar *strip_prefix);

static PyObject *
_helper_wrap_gobject_glist (const GList *list)
{
    PyObject *py_list;
    const GList *tmp;

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *py_obj = pygobject_new(G_OBJECT(tmp->data));

        if (py_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, py_obj);
        Py_DECREF(py_obj);
    }
    return py_list;
}

static PyObject *
_helper_wrap_gobject_gslist (const GSList *list)
{
    PyObject *py_list;
    const GSList *tmp;

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *py_obj = pygobject_new(G_OBJECT(tmp->data));

        if (py_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, py_obj);
        Py_DECREF(py_obj);
    }
    return py_list;
}

static int
_helper_wrap_message_types(PyObject *args, const gchar ***keys, GType **types, gint *num, gboolean direct)
{
    guint len, i;
    
    len = PyTuple_Size(args);

    if (len == 1 && PyDict_Check(PyTuple_GetItem(args, 0)))
    {
    	/* get key -> gtype from mapping */
    	PyObject *dict = PyTuple_GetItem(args, 0);
    	PyObject *key;
    	PyObject *value;

    	*num = PyDict_Size(dict);
    	*types = g_new(GType, num);
        *keys = g_new(const gchar *, num);
        
        while (PyDict_Next(dict, &i, &key, &value)) {
            *keys[i] = PyString_AsString(key);
            
            if (direct) {
                *types[i] = pyg_type_from_object(value);
            } else {
                PyObject *pytype = PyObject_Type(value);
                *types[i] = pytype ? pyg_type_from_object(pytype) : 0;
                Py_DECREF(pytype);
            }
            
            if (*types[i] == 0 || *keys[i] == NULL) {
                g_free(*types);
                g_free(*keys);
                return 0;
            }
        }
    }
    else
    {
        if (len % 2 != 0) {
            PyErr_SetString(PyExc_TypeError,
                            "Even number of arguments expected (name/type pairs)");
            return 0;
        }

        *num = len / 2;
        *types = g_new(GType, *num);
        *keys = g_new(const gchar *, *num);

        for (i = 0; i < *num; i++) {
            PyObject *key = PyTuple_GetItem(args, i * 2);
            PyObject *value = PyTuple_GetItem(args, i * 2 + 1);
    
            *keys[i] = PyString_AsString(key);
            
            if (direct) {
                *types[i] = pyg_type_from_object(value);
            } else {
                PyObject *pytype = PyObject_Type(value);
                *types[i] = pytype ? pyg_type_from_object(pytype) : 0;
                Py_DECREF(pytype);
            }

            if (*types[i] == 0 || *keys[i] == NULL) {
                g_free(*types);
                g_free(*keys);
                return 0;
            }
        }
    }
    
    return 1;
}

static int
_helper_wrap_message_set_value(PyGObject *self, PyObject *pykey, PyObject *pyvalue)
{
    const gchar *key;
    GType gtype;
    GValue value = {0,};

    key = PyString_AsString(pykey);
    
    if (key == NULL)
        return 0;

    gtype = gedit_message_get_key_type(GEDIT_MESSAGE(self->obj), key);
    
    if (gtype == 0) {
        PyErr_SetString(PyExc_TypeError, "invalid key");
        return 0;
    }

    g_value_init(&value, gtype);
    
    if (pyg_value_from_pyobject(&value, pyvalue)) {
        PyErr_SetString(PyExc_TypeError,
                        "value is of the wrong type for this key");
        return 0;
    }

    gedit_message_set_value(GEDIT_MESSAGE(self->obj), key, &value);
    g_value_unset(&value);
    
    return 1;
}

static int
_helper_wrap_message_set_values(PyGObject *self, PyObject *args)
{
    guint len, i;
    
    len = PyTuple_Size(args);

    if (len == 1 && PyDict_Check(PyTuple_GetItem(args, 0)))
    {
    	/* do key -> value from mapping */
    	PyObject *dict = PyTuple_GetItem(args, 0);
    	PyObject *pykey, *pyvalue;

        while (PyDict_Next(dict, &i, &pykey, &pyvalue)) {
            if (!_helper_wrap_message_set_value(self, pykey, pyvalue))
                return 0;
        }
    } else {
        if (len % 2 != 0) {
            PyErr_SetString(PyExc_TypeError,
                            "Even number of arguments expected (name/type pairs)");
            return 0;
        }

        for (i = 0; i < len / 2; i++) {
            PyObject *pykey = PyTuple_GetItem(args, i * 2);
            PyObject *pyvalue = PyTuple_GetItem(args, i * 2 + 1);
            
            if (!_helper_wrap_message_set_value(self, pykey, pyvalue))
                return 0;
        }
    }
    
    return 1;
}

static GeditMessage *
_helper_wrap_create_message(PyObject *args)
{
    guint len, num;
    const gchar *domain;
    const gchar *name;
    GType *types;
    const gchar **keys;
    PyObject *slice;
    GeditMessage *message;

    len = PyTuple_Size(args);

    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "GeditMessage requires at least two arguments");
        return NULL;
    }
    
    domain = PyString_AsString(PyTuple_GetItem(args, 0));
    name = PyString_AsString(PyTuple_GetItem(args, 1));
    
    if (!domain || !name) {
        PyErr_SetString(PyExc_TypeError,
                        "First two arguments need to be strings");
        return NULL;
    }
    
    slice = PyTuple_GetSlice (args, 2, len);

    if (!_helper_wrap_message_types (slice, &keys, &types, &num, FALSE)) {
        Py_DECREF(slice);
    	return NULL;
    }

    message = g_object_new(GEDIT_TYPE_MESSAGE, "domain", domain, "name", name, NULL);
    gedit_message_set_types (message, keys, types, num);

    g_free(types);
    g_free(keys);

    return message;
}

typedef struct {
    PyObject *func;
    PyObject *data;
} PyGeditCustomNotify;

static void 
pygedit_custom_destroy_notify(gpointer user_data)
{
    PyGeditCustomNotify *cunote = user_data;
    PyGILState_STATE state;
    
    g_return_if_fail(user_data);
    state = pyg_gil_state_ensure();
    Py_XDECREF(cunote->func);
    Py_XDECREF(cunote->data);
    pyg_gil_state_release(state);
    
    g_free(cunote);
}

%%
modulename gedit 
%%
import gtk.Widget as PyGtkWidget_Type
import gobject.GObject as PyGObject_Type
import gtk.gdk.Screen as PyGdkScreen_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.Window as PyGtkWindow_Type
import gtk.Image as PyGtkImage_Type
import gtk.Statusbar as PyGtkStatusbar_Type
import gtksourceview2.Buffer as PyGtkSourceBuffer_Type
import gtksourceview2.View as PyGtkSourceView_Type
import gtksourceview2.Language as PyGtkSourceLanguage_Type
import gtksourceview2.LanguageManager as PyGtkSourceLanguageManager_Type
%%
ignore-glob
  *_get_type
  gedit_document_error_quark
  gedit_panel_add_item_with_stock_icon
  gedit_message_new_valist
  gedit_message_get_valist
  gedit_message_set_valist
  gedit_message_set_valuesv
  gedit_message_bus_disconnect_by_func
  gedit_message_bus_block_by_func
  gedit_message_bus_unblock_by_func
%%
override gedit_app_create_window kwargs
static PyObject *
_wrap_gedit_app_create_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL};
    PyGObject *screen = NULL;
    GeditWindow *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"|O!", kwlist,
			&PyGdkScreen_Type, &screen))
        return NULL;

    ret = gedit_app_create_window(GEDIT_APP(self->obj),
				  screen ? GDK_SCREEN(screen->obj) : NULL);

    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gedit_app_get_windows
static PyObject *
_wrap_gedit_app_get_windows(PyGObject *self)
{
    const GList *list;
    PyObject *py_list;

    list = gedit_app_get_windows (GEDIT_APP (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    return py_list;
}
%%
override gedit_app_get_views
static PyObject *
_wrap_gedit_app_get_views(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = gedit_app_get_views (GEDIT_APP (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    g_list_free (list);

    return py_list;
}
%%
override gedit_app_get_documents
static PyObject *
_wrap_gedit_app_get_documents(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = gedit_app_get_documents (GEDIT_APP (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    g_list_free (list);

    return py_list;
}
%%
override gedit_window_get_documents
static PyObject *
_wrap_gedit_window_get_documents(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = gedit_window_get_documents (GEDIT_WINDOW (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    g_list_free(list);

    return py_list;
}
%%
override gedit_window_get_unsaved_documents
static PyObject *
_wrap_gedit_window_get_unsaved_documents(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = gedit_window_get_unsaved_documents (GEDIT_WINDOW (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    g_list_free(list);

    return py_list;
}
%%
override gedit_window_get_views
static PyObject *
_wrap_gedit_window_get_views(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = gedit_window_get_views (GEDIT_WINDOW (self->obj));

    py_list = _helper_wrap_gobject_glist (list);

    g_list_free(list);

    return py_list;
}
%%
override gedit_window_close_tabs kwargs
static PyObject *
_wrap_gedit_window_close_tabs (PyGObject *self,
			       PyObject  *args,
			       PyObject  *kwargs)
{
	static char *kwlist[] = { "tabs", NULL };
	PyObject *list, *item;
	GList *glist = NULL;
	int len, i;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "O:GeditWindow.close_tabs", kwlist,
					  &list))
		return NULL;

	if (!PySequence_Check (list))
	{
		PyErr_SetString (PyExc_TypeError,
				 "first argument must be a sequence");
		return NULL;
	}

	len = PySequence_Length (list);

	for (i = 0; i < len; i++)
	{
		item = PySequence_GetItem (list, i);
		Py_DECREF(item);

		if (!pygobject_check (item, &PyGeditTab_Type))
		{
			PyErr_SetString (PyExc_TypeError,
					 "sequence item not a Gtkwidget object");
			g_list_free (glist);
			return NULL;
		}

		glist = g_list_append (glist, pygobject_get (item));
	}

	gedit_window_close_tabs (GEDIT_WINDOW (self->obj), glist);

	g_list_free (glist);
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override gedit_document_get_search_text
static PyObject *
_wrap_gedit_document_get_search_text(PyGObject *self)
{
    PyObject *tuple, *string;
    guint flags;
    gchar *ret;

    ret = gedit_document_get_search_text (GEDIT_DOCUMENT (self->obj), &flags);

    tuple = PyTuple_New(2);
    if (ret) {
        string = PyString_FromString(ret);
        PyTuple_SetItem(tuple, 0, string);
        Py_DECREF(string);
    } else {
        PyTuple_SetItem(tuple, 0, Py_None);
    }
    PyTuple_SetItem(tuple, 1, PyInt_FromLong(flags));

    g_free(ret);

    return tuple;
}
%%
override gedit_panel_add_item kwargs
static PyObject *
_wrap_gedit_panel_add_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist1[] = { "item", "name", "image", NULL };
    static char *kwlist2[] = { "item", "name", "stock_id", NULL };
    PyGObject *item, *image;
    char *name = NULL;
    char *stock_id = NULL;

    if (PyArg_ParseTupleAndKeywords(args, kwargs, "O!sO!:GeditPanel.add_item", kwlist1, &PyGtkWidget_Type, &item, &name, &PyGtkImage_Type, &image)) {
        gedit_panel_add_item(GEDIT_PANEL(self->obj), GTK_WIDGET(item->obj), name, GTK_WIDGET(image->obj));
        Py_INCREF(Py_None);
        return Py_None;
    }

    PyErr_Clear();

    if (PyArg_ParseTupleAndKeywords(args, kwargs, "O!ss:GeditPanel.add_item", kwlist2, &PyGtkWidget_Type, &item, &name, &stock_id)) {
        gedit_panel_add_item_with_stock_icon(GEDIT_PANEL(self->obj), GTK_WIDGET(item->obj), name, stock_id);
        Py_INCREF(Py_None);
        return Py_None;
    }

    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError, "the last arg should be either a gtk.Image or a stock_id string");
    return NULL;
}
%%
override gedit_app_get_default_deprecated
/* deprecated wrappers */
static PyObject *
_wrap_gedit_app_get_default_deprecated(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.app_get_default instead") < 0)
	return NULL;
    return _wrap_gedit_app_get_default(self);
}
%%
override gedit_encoding_get_from_charset_deprecated kwargs
static PyObject *
_wrap_gedit_encoding_get_from_charset_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.encoding_get_from_charset instead") < 0)
	return NULL;
    return _wrap_gedit_encoding_get_from_charset(self, args, kwargs);
}
%%
override gedit_encoding_get_from_index_deprecated kwargs
static PyObject *
_wrap_gedit_encoding_get_from_index_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.encoding_get_from_index instead") < 0)
	return NULL;
    return _wrap_gedit_encoding_get_from_index(self, args, kwargs);
}
%%
override gedit_encoding_get_utf8_deprecated
static PyObject *
_wrap_gedit_encoding_get_utf8_deprecated(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.encoding_get_utf8 instead") < 0)
	return NULL;
    return _wrap_gedit_encoding_get_utf8(self);
}
%%
override gedit_encoding_get_current_deprecated
static PyObject *
_wrap_gedit_encoding_get_current_deprecated(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.encoding_get_current instead") < 0)
	return NULL;
    return _wrap_gedit_encoding_get_current(self);
}
%%
override gedit_tab_get_from_document_deprecated kwargs
static PyObject *
_wrap_gedit_tab_get_from_document_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gedit.tab_get_from_document instead") < 0)
	return NULL;
    return _wrap_gedit_tab_get_from_document(self, args, kwargs);
}
%%
override gedit_language_manager_list_languages_sorted kwargs
static PyObject *
_wrap_gedit_language_manager_list_languages_sorted(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lm", "include_hidden", NULL };
    PyGObject *lm;
    int include_hidden;
    PyObject *py_list;
    GSList *list;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O!i:language_manager_list_languages_sorted",
                                      kwlist, &PyGtkSourceLanguageManager_Type, &lm,
                                      &include_hidden))
        return NULL;

    list = gedit_language_manager_list_languages_sorted (GTK_SOURCE_LANGUAGE_MANAGER (lm->obj),
                                                         include_hidden);

    py_list = _helper_wrap_gobject_gslist (list);

    g_slist_free (list);

    return py_list;
}
%%
override gedit_debug kwargs
static PyObject *
_wrap_gedit_debug(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "message", NULL };
    PyObject *traceback_module, *mdict, *func, *traceback, *tuple;
    PyObject *filename, *lineno, *funcname;
    char *message = NULL;

    if (g_getenv ("GEDIT_DEBUG_PLUGINS") == NULL)
    {
        Py_INCREF (Py_None);
        return Py_None;
    }

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|s", kwlist, &message))
        return NULL;

    traceback_module = PyImport_ImportModule ("traceback");
    if (traceback_module == NULL)
    {
        g_warning ("traceback module cannot be imported");
        Py_INCREF (Py_None);
        return Py_None;
    }

    mdict = PyModule_GetDict (traceback_module);
    func = PyDict_GetItemString (mdict, "extract_stack");
    traceback = PyObject_CallFunction (func, "zi", NULL, 1);
    tuple = PyList_GetItem (traceback, 0);

    if (tuple == NULL || !PyTuple_Check (tuple))
    {
        g_warning ("traceback tuple is null!");
    }
    else
    {
        filename = PyTuple_GetItem (tuple, 0);
        lineno = PyTuple_GetItem (tuple, 1);
        funcname = PyTuple_GetItem (tuple, 2);

        if (message == NULL)
            gedit_debug (GEDIT_DEBUG_PLUGINS,
                         PyString_AsString (filename),
                         PyInt_AsLong (lineno),
                         PyString_AsString (funcname));
        else
            gedit_debug_message (GEDIT_DEBUG_PLUGINS,
                                 PyString_AsString (filename),
                                 PyInt_AsLong (lineno),
                                 PyString_AsString (funcname),
                                 message);
    }
    Py_DECREF (traceback);
    Py_DECREF (traceback_module);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gedit_message_new
static int
_wrap_gedit_message_new(PyGObject *self, PyObject *args)
{
    self->obj = (GObject *)_helper_wrap_create_message(args);
    
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GeditMessage object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);

    return 0;
}
%%
override gedit_message_set_types args
static PyObject *
_wrap_gedit_message_set_types(PyGObject *self, PyObject *args)
{
    guint num;
    GType *types;
    const gchar **keys;

    if (!_helper_wrap_message_types (args, &keys, &types, &num, TRUE)) {
    	return NULL;
    }
 
    gedit_message_set_types (GEDIT_MESSAGE(self->obj), keys, types, num);

    g_free(types);
    g_free(keys);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gedit_message_get args
static PyObject *
_wrap_gedit_message_get(PyGObject *self, PyObject *args)
{
    guint len, i;
    PyObject *ret;

    len = PyTuple_Size(args);
    
    ret = PyTuple_New(len);
    
    for (i = 0; i < len; i++) {
        GValue value = { 0, };
        PyObject *py_key = PyTuple_GetItem(args, i);
        const gchar *key;
        
        if (!PyString_Check(py_key)) {
	    PyErr_SetString(PyExc_TypeError, "keys must be strings");
	    Py_DECREF(ret);
	    return NULL;
	}
	
	key = PyString_AsString(py_key);
	gedit_message_get_value (GEDIT_MESSAGE (self->obj), key, &value);
	
	PyTuple_SetItem(ret, i, pyg_value_as_pyobject(&value, TRUE));
	g_value_unset(&value);
    }
    
    return ret;
}
%%
override gedit_message_get_value kwargs
static PyObject *
_wrap_gedit_message_get_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    const gchar *key;
    PyObject *ret;
    GValue value = { 0, };
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GeditMessage.get_value", kwlist, &key))
        return NULL;

    gedit_message_get_value(GEDIT_MESSAGE(self->obj), key, &value);
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    
    return ret;
}
%%
override gedit_message_set_value kwargs
static PyObject *
_wrap_gedit_message_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    PyObject *ret, *pykey, *pyvalue;
    GValue value = { 0, };
    GType gtype;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:GeditMessage.set_value", kwlist, &pykey, &pyvalue))
        return NULL;
    
    if (!_helper_wrap_message_set_value(self, pykey, pyvalue))
        return NULL;
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gedit_message_set args
static PyObject *
_wrap_gedit_message_set (PyGObject *self, PyObject *args) {
    if (!_helper_wrap_message_set_values(self, args))
        return NULL;
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gedit_message_bus_connect kwargs
static void
pygedit_message_bus_connect_cb(GeditMessageBus *bus, GeditMessage *message, gpointer data)
{
    PyGILState_STATE state;
    PyGeditCustomNotify *cunote = data;
    PyObject *pybus, *pymessage, *retobj;
    gboolean ret = FALSE;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    pybus = pygobject_new((GObject *)bus);
    pymessage = pygobject_new((GObject *)message);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)", pybus, pymessage, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", pybus, pymessage);
    }

    if (PyErr_Occurred()) {
        PyErr_Print();
    }

    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gedit_message_bus_connect(PyGObject *self, PyObject *args, PyObject *kwargs) 
{
    static char *kwlist[] = { "domain", "name", "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    const gchar *domain;
    const gchar *name;
    PyGeditCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ssO|O:GeditMessageBus.connect",
				     kwlist, &domain, &name, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new(PyGeditCustomNotify, 1);
    Py_INCREF(pyfunc);
    cunote->func = pyfunc;
    Py_XINCREF(pyarg);
    cunote->data = pyarg;

    gedit_message_bus_connect(GEDIT_MESSAGE_BUS(self->obj),
                              domain,
                              name,
                              pygedit_message_bus_connect_cb,
                              (gpointer)cunote,
                              pygedit_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gedit_message_bus_send args
static PyObject *
_wrap_gedit_message_bus_send (PyGObject *self, PyObject *args)
{
    /* create a new message object */
    GeditMessage *message;
    
    message = _helper_wrap_create_message(args);
    
    if (!message)
        return NULL;
    
    gedit_message_bus_send_message(GEDIT_MESSAGE_BUS(self->obj), message);
    g_object_unref (message);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gedit_message_bus_send_sync args
static PyObject *
_wrap_gedit_message_bus_send_sync (PyGObject *self, PyObject *args)
{
    /* create a new message object */
    GeditMessage *message;
    
    message = _helper_wrap_create_message(args);
    
    if (!message)
        return NULL;
    
    gedit_message_bus_send_message_sync(GEDIT_MESSAGE_BUS(self->obj), message);
    return pygobject_new((GObject *)message);
}
%%
