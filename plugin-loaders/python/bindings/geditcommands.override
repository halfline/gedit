%%
headers
#define NO_IMPORT_PYGOBJECT
#define NO_IMPORT_PYGTK
#include <pygobject.h>
#include <pygtk/pygtk.h>

#include "gedit-commands.h"
#include "gedit-window.h"

void pygeditcommands_register_classes (PyObject *d);
void pygeditcommands_add_constants (PyObject *module, const gchar *strip_prefix);

%%
modulename gedit.commands
%%
import gedit.Window as PyGeditWindow_Type
import gedit.Document as PyGeditDocument_Type
import gio.File as PyGFile_Type
%%
ignore-glob
  _*
%%
override gedit_commands_load_location kwargs 
static PyObject *
_wrap_gedit_commands_load_location (PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "window", "location", "encoding", "line_pos", "column_pos", NULL };
	PyGObject *window;
	PyGObject *location;
	int line_pos = 0;
	int column_pos = 0;
	PyObject *py_encoding = NULL;
	GeditEncoding *encoding = NULL;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!O!|Oii:load_location", 
	                                  kwlist, &PyGeditWindow_Type,
	                                  &window, &PyGFile_Type, &location,
	                                  &py_encoding, &line_pos, &column_pos))
		return NULL;

	if (py_encoding != NULL && py_encoding != Py_None)
	{
		if (pyg_boxed_check (py_encoding, GEDIT_TYPE_ENCODING))
			encoding = pyg_boxed_get (py_encoding, GeditEncoding);
		else
		{
			PyErr_SetString (PyExc_TypeError,
			                 "encoding should be a GeditEncoding");
			return NULL;
		}
	}

	gedit_commands_load_location (GEDIT_WINDOW (window->obj), G_FILE (location->obj),
	                              encoding, line_pos, column_pos);
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override gedit_commands_load_locations kwargs 
static PyObject *
_wrap_gedit_commands_load_locations (PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "window", "locations", "encoding", "line_pos", "column_pos", NULL };
	PyGObject *window;
	GSList *locations = NULL;
	int line_pos = 0;
	int column_pos = 0;
	PyObject *py_encoding = NULL;
	PyObject *list;
	PyObject *item;
	GeditEncoding *encoding = NULL;
	int len;
	int i;
	GSList *loaded;
	GSList *doc;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!O|Oii:load_locations",
	                                  kwlist, &PyGeditWindow_Type,
	                                  &window, &list, &py_encoding,
	                                  &line_pos, &column_pos))
		return NULL;

	if (py_encoding != NULL && py_encoding != Py_None)
	{
		if (pyg_boxed_check (py_encoding, GEDIT_TYPE_ENCODING))
			encoding = pyg_boxed_get (py_encoding, GeditEncoding);
		else {
			PyErr_SetString (PyExc_TypeError, 
			                 "encoding should be a GeditEncoding");
			return NULL;
		}
	}

	if (!PySequence_Check (list))
	{
		PyErr_SetString (PyExc_TypeError, 
		                 "second argument must be a sequence");
		return NULL;
	}

	len = PySequence_Length (list);

	for (i = 0; i < len; i++)
	{
		item = PySequence_GetItem (list, i);
		Py_DECREF (item);

		if (!pygobject_check (item, &PyGFile_Type))
		{
			PyErr_SetString (PyExc_TypeError,
					 "sequence item not a GFile");
			g_slist_free (locations);
			return NULL;
		}

		locations = g_slist_prepend (locations, pygobject_get (item));
	}

	locations = g_slist_reverse (locations);
	loaded = gedit_commands_load_locations (GEDIT_WINDOW (window->obj), locations,
	                                        encoding, line_pos, column_pos);
	g_slist_free (locations);

	if ((list = PyList_New(0)) == NULL)
	{
		g_slist_free (loaded);
		return NULL;
	}

	for (doc = loaded; doc; doc = g_slist_next (doc))
	{
		PyObject *py_obj = pygobject_new (G_OBJECT (doc->data));

		if (py_obj == NULL)
		{
			g_slist_free (loaded);

			Py_DECREF(list);
			return NULL;
		}

		PyList_Append(list, py_obj);
		Py_DECREF(py_obj);
	}

	g_slist_free (loaded);

	return list;
}
